module shift_card(
    input wire VCC,
    input wire GND,
    input wire clk,				// generated by motherboard clock generator
    input wire rst_n,			// probably a button on the motherboard
    input wire we_n,			    // active low
    input wire oe_n,			    // active low
    inout wire [7:0] data,
    input wire [15:0] addr,	    // 64k address space is suppored by default. More address bits may be added later
    output wire int_n,			// pulled up by motherboard; driven down by any peripheral (could be used for interrupts)
    output wire [7:0] aux_bus,
    output reg [7:0] TO_BUFFER_DATA,
    output wire TO_BUFFER_OE_N,
    output wire TO_AUX_BUS
);

// TODO: COMMENT THIS OUT BEFORE SYNTHESIS
assign data = TO_BUFFER_OE_N == 1'b0 ? TO_BUFFER_DATA : 8'bz;


parameter CARD_ADDRESS = 5'b1000_1;
// The card is selected when addr == 16'b1000_1xxx_xxxx_xxxx;
// Address space size = 2Kb

// bottom half of address space during writes is ALU a; top half ALU b
//    this means that when addr[10] == 0, we are writing to a; when addr[10] == 1, we are writing to b

// when reading, there are 8 places to read from
//    this means that addr[10:8] selects the operation to perform when reading


reg [7:0] a, b;

assign TO_BUFFER_OE_N = !(oe_n == 1'b0 && addr[15:11] == CARD_ADDRESS);
assign TO_AUX_BUS = ~(a == b);


always @(posedge clk) begin
    if (addr[15:11] == CARD_ADDRESS && we_n == 1'b0) begin
        if (addr[10] == 1'b0)
            a <= data;
        else
            b <= data;
    end
end

always @(*) begin
    case (addr[10:8])
        // swap upper and lower of a
        3'b000: TO_BUFFER_DATA = {a[3:0], a[7:4]};

        // left logical shift a by 1
        3'b001: TO_BUFFER_DATA = a >> 1;

        // left circular shift a by 1
        3'b010: TO_BUFFER_DATA = {a[6:0], a[7]};

        // left arithmetic shift a by 1
        3'b011: TO_BUFFER_DATA = $signed(a) >>> 1;

        // right logical shift a by 1
        3'b100: TO_BUFFER_DATA = a << 1;

        // right circular shift a by 1
        3'b101: TO_BUFFER_DATA = {a[0], a[7:1]};

        3'b110: TO_BUFFER_DATA = 8'bx;
        3'b111: TO_BUFFER_DATA = 8'bx;
        default: TO_BUFFER_DATA = 8'bx;
    endcase
end

endmodule